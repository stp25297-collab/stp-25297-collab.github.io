<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Kaimalav Battle Royale</title>
<style>
  body {
    background-color: #333;
    color: #eee;
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    flex-direction: column;
    position: relative; /* เพิ่มเพื่อให้สามารถวางตำแหน่ง h1 ได้ */
  }
  h1 {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 1.5em;
    color: #fff;
    text-shadow: 2px 2px 4px #000;
  }
  canvas {
    background-color: #555;
    border: 2px solid #ccc;
  }
  #game-ui {
    margin-top: 10px;
    font-size: 1.2em;
    text-align: center;
  }
  .player-info {
    display: flex;
    justify-content: space-around;
    width: 100%;
    max-width: 800px;
    margin-top: 20px;
  }
  .player-info div {
    padding: 10px;
    background-color: #444;
    border-radius: 5px;
  }
</style>
</head>
<body>

<h1>Kaimalav Battle Royale</h1>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<div id="game-ui">
  <div id="status-message"></div>
</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusMessage = document.getElementById('status-message');

  const PLAYER_SIZE = 20;
  const ENEMY_SIZE = 15;
  const ITEM_SIZE = 10;
  const PROJECTILE_SIZE = 5;
  const HEALING_AMOUNT = 30;

  const player = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    health: 100,
    maxHealth: 100,
    speed: 3,
    color: 'lightblue',
    lastShot: 0,
    fireRate: 200, // milliseconds
    canHeal: true,
    lastHeal: 0,
    healCooldown: 5000 // milliseconds
  };

  let enemies = [];
  let projectiles = [];
  let items = [];
  let keys = {};
  let mouse = { x: 0, y: 0, isDown: false };
  let gameStarted = false;
  let gameOver = false;
  let remainingPlayers = 0;

  function createEnemy() {
    let x, y;
    do {
      x = Math.random() * (canvas.width - ENEMY_SIZE);
      y = Math.random() * (canvas.height - ENEMY_SIZE);
    } while (getDistance(x, y, player.x, player.y) < 200);

    enemies.push({
      x,
      y,
      health: 50,
      color: 'red',
      speed: 1.5,
      lastShot: 0,
      fireRate: 1000,
      target: player
    });
  }

  function createItem() {
    items.push({
      x: Math.random() * (canvas.width - ITEM_SIZE),
      y: Math.random() * (canvas.height - ITEM_SIZE),
      color: 'lightgreen',
      type: 'health'
    });
  }

  function getDistance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
  }

  function drawPlayer() {
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);
    
    // Health bar
    ctx.fillStyle = 'red';
    ctx.fillRect(player.x, player.y - 10, PLAYER_SIZE, 5);
    ctx.fillStyle = 'green';
    ctx.fillRect(player.x, player.y - 10, PLAYER_SIZE * (player.health / player.maxHealth), 5);
  }

  function drawEnemies() {
    enemies.forEach(enemy => {
      ctx.fillStyle = enemy.color;
      ctx.fillRect(enemy.x, enemy.y, ENEMY_SIZE, ENEMY_SIZE);
    });
  }

  function drawProjectiles() {
    ctx.fillStyle = 'yellow';
    projectiles.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, PROJECTILE_SIZE, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawItems() {
    items.forEach(item => {
      ctx.fillStyle = item.color;
      ctx.beginPath();
      ctx.arc(item.x, item.y, ITEM_SIZE, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function updatePlayer() {
    let newX = player.x;
    let newY = player.y;

    if (keys['w'] || keys['W'] || keys['ArrowUp']) newY -= player.speed;
    if (keys['s'] || keys['S'] || keys['ArrowDown']) newY += player.speed;
    if (keys['a'] || keys['A'] || keys['ArrowLeft']) newX -= player.speed;
    if (keys['d'] || keys['D'] || keys['ArrowRight']) newX += player.speed;

    // Check for collision with canvas boundaries
    if (newX >= 0 && newX + PLAYER_SIZE <= canvas.width) {
      player.x = newX;
    }
    if (newY >= 0 && newY + PLAYER_SIZE <= canvas.height) {
      player.y = newY;
    }
    
    // Check for item pickup
    items = items.filter(item => {
      const distance = getDistance(player.x + PLAYER_SIZE / 2, player.y + PLAYER_SIZE / 2, item.x, item.y);
      if (distance < PLAYER_SIZE / 2 + ITEM_SIZE) {
        if (item.type === 'health') {
          player.canHeal = true;
          statusMessage.textContent = 'Health Pack picked up! Press E to heal.';
        }
        return false; // Item is picked up
      }
      return true; // Item is not picked up
    });
  }

  function updateEnemies() {
    enemies.forEach(enemy => {
      const dx = player.x + PLAYER_SIZE / 2 - (enemy.x + ENEMY_SIZE / 2);
      const dy = player.y + PLAYER_SIZE / 2 - (enemy.y + ENEMY_SIZE / 2);
      const angle = Math.atan2(dy, dx);
      enemy.x += Math.cos(angle) * enemy.speed;
      enemy.y += Math.sin(angle) * enemy.speed;

      // Enemy shooting
      const now = Date.now();
      if (now - enemy.lastShot > enemy.fireRate) {
        const p_dx = player.x + PLAYER_SIZE / 2 - (enemy.x + ENEMY_SIZE / 2);
        const p_dy = player.y + PLAYER_SIZE / 2 - (enemy.y + ENEMY_SIZE / 2);
        const p_angle = Math.atan2(p_dy, p_dx);

        projectiles.push({
          x: enemy.x + ENEMY_SIZE / 2,
          y: enemy.y + ENEMY_SIZE / 2,
          vx: Math.cos(p_angle) * 5,
          vy: Math.sin(p_angle) * 5,
          fromPlayer: false
        });
        enemy.lastShot = now;
      }
    });
  }

  function updateProjectiles() {
    projectiles = projectiles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;

      // Check for collision with canvas boundaries
      if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
        return false;
      }

      if (p.fromPlayer) {
        // Check for collision with enemies
        for (let i = 0; i < enemies.length; i++) {
          const enemy = enemies[i];
          const distance = getDistance(p.x, p.y, enemy.x + ENEMY_SIZE / 2, enemy.y + ENEMY_SIZE / 2);
          if (distance < PROJECTILE_SIZE + ENEMY_SIZE / 2) {
            enemies.splice(i, 1);
            remainingPlayers--;
            if (Math.random() > 0.5) {
              createItem();
            }
            return false; // Remove projectile
          }
        }
      } else {
        // Check for collision with player
        const distance = getDistance(p.x, p.y, player.x + PLAYER_SIZE / 2, player.y + PLAYER_SIZE / 2);
        if (distance < PROJECTILE_SIZE + PLAYER_SIZE / 2) {
          player.health -= 10;
          if (player.health <= 0) {
            endGame('lost');
          }
          return false; // Remove projectile
        }
      }

      return true; // Keep projectile
    });
  }

  function shoot(targetX, targetY) {
    const now = Date.now();
    if (now - player.lastShot > player.fireRate) {
      const dx = targetX - (player.x + PLAYER_SIZE / 2);
      const dy = targetY - (player.y + PLAYER_SIZE / 2);
      const angle = Math.atan2(dy, dx);
      
      projectiles.push({
        x: player.x + PLAYER_SIZE / 2,
        y: player.y + PLAYER_SIZE / 2,
        vx: Math.cos(angle) * 8,
        vy: Math.sin(angle) * 8,
        fromPlayer: true
      });
      player.lastShot = now;
    }
  }

  function updateGameStatus() {
    if (enemies.length === 0) {
      endGame('won');
    }
    
    let message = `Health: ${player.health} | Enemies Left: ${enemies.length}`;
    if (player.canHeal) {
      message += ' | (Press E to use health pack)';
    } else if (Date.now() - player.lastHeal < player.healCooldown) {
      const remainingTime = Math.ceil((player.healCooldown - (Date.now() - player.lastHeal)) / 1000);
      message += ` | Healing Cooldown: ${remainingTime}s`;
    }
    
    statusMessage.textContent = message;
  }

  function gameLoop() {
    if (gameOver) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    updatePlayer();
    updateEnemies();
    updateProjectiles();

    drawPlayer();
    drawEnemies();
    drawProjectiles();
    drawItems();
    
    updateGameStatus();

    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    if (gameStarted) return;
    
    gameStarted = true;
    gameOver = false;
    player.health = 100;
    enemies = [];
    projectiles = [];
    items = [];
    
    const numEnemies = 10;
    for (let i = 0; i < numEnemies; i++) {
      createEnemy();
    }
    remainingPlayers = numEnemies;
    
    statusMessage.textContent = 'Game Started! Good luck.';
    gameLoop();
  }
  
  function endGame(result) {
    gameOver = true;
    if (result === 'won') {
      statusMessage.textContent = 'Congratulations! You won!';
      document.body.style.backgroundColor = '#28a745';
    } else {
      statusMessage.textContent = 'Game Over! You were defeated.';
      document.body.style.backgroundColor = '#dc3545';
    }
    
    // Add a restart button
    const restartBtn = document.createElement('button');
    restartBtn.textContent = 'Restart Game';
    restartBtn.onclick = () => {
        document.body.style.backgroundColor = '#333';
        restartBtn.remove();
        startGame();
    };
    statusMessage.appendChild(restartBtn);
  }

  // Event Listeners
  window.addEventListener('keydown', e => {
    keys[e.key] = true;
    if (e.key === 'E' || e.key === 'e') {
      if (player.canHeal) {
        player.health = Math.min(player.health + HEALING_AMOUNT, player.maxHealth);
        player.canHeal = false;
        player.lastHeal = Date.now();
        statusMessage.textContent = `Healed! Cooldown initiated.`;
      }
    }
  });
  window.addEventListener('keyup', e => {
    keys[e.key] = false;
  });
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });
  canvas.addEventListener('mousedown', e => {
    if (e.button === 0) { // Left click
      mouse.isDown = true;
    }
  });
  canvas.addEventListener('mouseup', e => {
    if (e.button === 0) {
      mouse.isDown = false;
    }
  });

  // Main game loop logic
  function mainLoop() {
    if (mouse.isDown) {
      shoot(mouse.x, mouse.y);
    }
    requestAnimationFrame(mainLoop);
  }
  mainLoop();
  
  // Initial start
  startGame();

</script>

</body>
</html>
